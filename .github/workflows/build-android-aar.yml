name: Build tun2socks AAR

on:
  workflow_dispatch:

jobs:
  build-aar:
    runs-on: ubuntu-latest

    env:
      JAVA_VERSION: '17'
      GO_VERSION: '1.21.13'
      ANDROID_SDK_ROOT: /usr/local/lib/android/sdk
      ANDROID_API: '34'
      ANDROID_BUILD_TOOLS: '34.0.0'
      ANDROID_NDK_VERSION: '26.3.11579264'
      TUN2SOCKS_V2: 'v2.6.0'
      TUN2SOCKS_V1: 'v1.18.3'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install Android cmdline-tools, SDK, build-tools, and NDK
        shell: bash
        run: |
          set -euxo pipefail

          # Ensure base directories
          sudo mkdir -p "${ANDROID_SDK_ROOT}"
          sudo chown -R "$USER":"$USER" "${ANDROID_SDK_ROOT}"

          # Install commandline-tools if missing
          if [ ! -d "${ANDROID_SDK_ROOT}/cmdline-tools/latest" ]; then
            wget -q https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip -O /tmp/cmdtools.zip
            mkdir -p /tmp/cmdtools
            unzip -q /tmp/cmdtools.zip -d /tmp/cmdtools
            mkdir -p "${ANDROID_SDK_ROOT}/cmdline-tools"
            mv /tmp/cmdtools/cmdline-tools "${ANDROID_SDK_ROOT}/cmdline-tools/latest"
          fi

          export PATH="${ANDROID_SDK_ROOT}/cmdline-tools/latest/bin:${ANDROID_SDK_ROOT}/platform-tools:${PATH}"

          yes | sdkmanager --licenses || true

          sdkmanager "platform-tools" "platforms;android-${ANDROID_API}" "build-tools;${ANDROID_BUILD_TOOLS}" "ndk;${ANDROID_NDK_VERSION}"

          # Expose NDK path
          echo "NDK_DIR=${ANDROID_SDK_ROOT}/ndk/${ANDROID_NDK_VERSION}" >> "$GITHUB_ENV"

      - name: Build libtun2socks.so (arm64) with v2â†’v1 fallback
        shell: bash
        run: |
          set -euxo pipefail

          # Workspace
          rm -rf core tun2socks-android || true
          mkdir -p core
          cd core

          go mod init example.com/tun2socks-wrapper

          # Write v2 wrapper
          cat > main_v2.go <<'EOF'
package main
/*
#include <stdlib.h>
*/
import "C"

import (
  "encoding/json"
  "fmt"
  "strings"
  ts "github.com/xjasonlyu/tun2socks/v2/engine"
)

var started bool

func buildConfig(fd int, proxy string) string {
  p := proxy
  if !strings.Contains(p, "://") {
    p = "socks5://" + p
  }
  cfg := map[string]any{
    "device":   map[string]any{"fdbased": map[string]any{"fd": fd}},
    "proxy":    map[string]any{"socks5":  map[string]any{"addr": p}},
    "netstack": map[string]any{"enable":  true},
  }
  b, _ := json.Marshal(cfg)
  return string(b)
}

//export tun2socks_start
func tun2socks_start(fd C.int, proxy *C.char) C.int {
  if started { return 0 }
  cfg := buildConfig(int(fd), C.GoString(proxy))
  ts.InsertJSON(cfg)
  ts.Start()
  started = true
  return 0
}

//export tun2socks_stop
func tun2socks_stop() C.int {
  if !started { return 0 }
  ts.Stop()
  started = false
  return 0
}

//export tun2socks_info
func tun2socks_info() *C.char {
  return C.CString(fmt.Sprintf("tun2socks v2: started=%v", started))
}

func main() {}
EOF

          # Write v1 wrapper
          cat > main_v1.go <<'EOF'
package main
/*
#include <stdlib.h>
*/
import "C"

import (
  "encoding/json"
  "fmt"
  "strings"
  ts "github.com/xjasonlyu/tun2socks/engine"
)

var started bool

func buildConfig(fd int, proxy string) string {
  p := proxy
  if !strings.Contains(p, "://") {
    p = "socks5://" + p
  }
  cfg := map[string]any{
    "device":   map[string]any{"fdbased": map[string]any{"fd": fd}},
    "proxy":    map[string]any{"socks5":  map[string]any{"addr": p}},
    "netstack": map[string]any{"enable":  true},
  }
  b, _ := json.Marshal(cfg)
  return string(b)
}

//export tun2socks_start
func tun2socks_start(fd C.int, proxy *C.char) C.int {
  if started { return 0 }
  cfg := buildConfig(int(fd), C.GoString(proxy))
  if err := ts.Start(cfg); err != nil {
    return -1
  }
  started = true
  return 0
}

//export tun2socks_stop
func tun2socks_stop() C.int {
  if !started { return 0 }
  ts.Stop()
  started = false
  return 0
}

//export tun2socks_info
func tun2socks_info() *C.char {
  return C.CString(fmt.Sprintf("tun2socks v1: started=%v", started))
}

func main() {}
EOF

          echo "Attempting v2 build ${TUN2SOCKS_V2}..."
          set +e
          go get "github.com/xjasonlyu/tun2socks/v2@${TUN2SOCKS_V2}" >/tmp/go_get_v2.log 2>&1 || true
          go mod tidy >/tmp/go_mod_tidy_v2.log 2>&1 || true

          mv main_v2.go main.go

          # NDK env
          if [ -z "${NDK_DIR:-}" ]; then
            echo "NDK_DIR not set" >&2
            exit 1
          fi

          CC="${NDK_DIR}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android${ANDROID_API}-clang"
          export CC
          export CGO_ENABLED=1
          export GOOS=android
          export GOARCH=arm64

          if go build -buildmode=c-shared -o libtun2socks.so >/tmp/build_v2.log 2>&1; then
            echo "Built v2"
            set -e
          else
            echo "v2 build failed; falling back to v1"
            cat /tmp/build_v2.log || true

            rm -f libtun2socks.so main.go || true
            rm -f go.mod go.sum || true
            go mod init example.com/tun2socks-wrapper

            echo "Fetching v1 ${TUN2SOCKS_V1}..."
            go get "github.com/xjasonlyu/tun2socks@${TUN2SOCKS_V1}" >/tmp/go_get_v1.log 2>&1 || true
            go mod tidy >/tmp/go_mod_tidy_v1.log 2>&1 || true

            mv main_v1.go main.go
            if go build -buildmode=c-shared -o libtun2socks.so >/tmp/build_v1.log 2>&1; then
              echo "Built v1"
              set -e
            else
              echo "v1 build failed"
              cat /tmp/build_v1.log || true
              exit 1
            fi
          fi
          set -e

          cd ..
          mkdir -p tun2socks-android/src/main/jniLibs/arm64-v8a
          cp core/libtun2socks.so tun2socks-android/src/main/jniLibs/arm64-v8a/

      - name: Create Android library project
        shell: bash
        run: |
          set -euxo pipefail

          mkdir -p tun2socks-android/src/main/java/com/example/tun2socks
          mkdir -p tun2socks-android/src/main/cpp
          mkdir -p tun2socks-android/src/main/jniLibs/arm64-v8a

          cat > tun2socks-android/src/main/java/com/example/tun2socks/Tun2Socks.java <<'EOF'
package com.example.tun2socks;

public class Tun2Socks {
    static {
        System.loadLibrary("tun2socks_jni");
        System.loadLibrary("tun2socks");
    }

    public static native int start(int tunFd, String proxyUrl);
    public static native int stop();
    public static native String coreInfo();
}
EOF

          cat > tun2socks-android/src/main/cpp/tun2socks_jni.c <<'EOF'
#include <jni.h>
#include <dlfcn.h>

typedef int (*start_fn)(int fd, const char *url);
typedef int (*stop_fn)();
typedef const char* (*info_fn)();

static void *handle; static start_fn core_start; static stop_fn core_stop; static info_fn core_info;

static void ensure_loaded() {
    if (handle) return;
    handle = dlopen("libtun2socks.so", RTLD_NOW);
    core_start = (start_fn)dlsym(handle, "tun2socks_start");
    core_stop  = (stop_fn)dlsym(handle, "tun2socks_stop");
    core_info  = (info_fn)dlsym(handle, "tun2socks_info");
}

JNIEXPORT jint JNICALL Java_com_example_tun2socks_Tun2Socks_start(JNIEnv *env,jclass,jint fd,jstring proxyUrl){
    ensure_loaded(); if(!core_start){return -2;}
    const char *url=(*env)->GetStringUTFChars(env,proxyUrl,0);
    int rc=core_start(fd,url);
    (*env)->ReleaseStringUTFChars(env,proxyUrl,url);
    return rc;
}

JNIEXPORT jint JNICALL Java_com_example_tun2socks_Tun2Socks_stop(JNIEnv *env,jclass){
    ensure_loaded(); if(!core_stop){return -2;}
    return core_stop();
}

JNIEXPORT jstring JNICALL Java_com_example_tun2socks_Tun2Socks_coreInfo(JNIEnv *env,jclass){
    ensure_loaded(); if(!core_info) return (*env)->NewStringUTF(env,"info not exported");
    const char *s=core_info();
    return (*env)->NewStringUTF(env,s?s:"null");
}
EOF

          cat > tun2socks-android/src/main/cpp/Android.mk <<'EOF'
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE    := tun2socks_jni
LOCAL_SRC_FILES := tun2socks_jni.c
LOCAL_LDLIBS    := -llog -ldl
include $(BUILD_SHARED_LIBRARY)
EOF

          cat > tun2socks-android/build.gradle <<'EOF'
plugins { id 'com.android.library' }
android {
    namespace "com.example.tun2socks"
    compileSdk 34
    defaultConfig {
        minSdk 21
        targetSdk 34
        ndk { abiFilters 'arm64-v8a' }
    }
    sourceSets {
        main {
            java.srcDirs = ['src/main/java']
            jniLibs.srcDirs = ['src/main/jniLibs']
        }
    }
    externalNativeBuild { ndkBuild { path "src/main/cpp/Android.mk" } }
}
EOF

          echo "include ':tun2socks-android'" > settings.gradle
          cat > build.gradle <<'EOF'
buildscript {
    repositories { google(); mavenCentral() }
    dependencies { classpath 'com.android.tools.build:gradle:8.4.0' }
}
allprojects { repositories { google(); mavenCentral() } }
EOF

      - name: Initialize Gradle wrapper
        shell: bash
        run: |
          set -euxo pipefail
          cd tun2socks-android
          gradle wrapper --gradle-version 8.4

      - name: Build AAR
        shell: bash
        run: |
          set -euxo pipefail
          cd tun2socks-android
          ./gradlew :assembleRelease --stacktrace

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: tun2socks-aar-arm64
          path: tun2socks-android/build/outputs/aar/*.aar
