name: Build tun2socks AAR from xjasonlyu/tun2socks

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]

env:
  GO_VERSION: '1.21'
  ANDROID_NDK_VERSION: '25.2.9519653'
  ANDROID_API: 21

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
    
    - name: Setup Android NDK
      uses: android-actions/setup-android@v3
    
    - name: Clone and setup tun2socks
      run: |
        # Clone the modern tun2socks implementation
        git clone https://github.com/xjasonlyu/tun2socks.git --depth=1
        
        cd tun2socks
        
        # Initialize and update Go modules
        go mod init github.com/xjasonlyu/tun2socks 2>/dev/null || true
        go mod tidy
        go mod download
        
        echo "Repository setup complete"
    
    - name: Build tun2socks binary for Android
      run: |
        cd tun2socks
        
        # Create a simple wrapper that uses the existing CLI
        cat > build_android.go << 'EOF'
        package main
        
        import (
            "fmt"
            "log"
            "os"
            "os/exec"
            "path/filepath"
        )
        
        func main() {
            // Build tun2socks for Android
            cmd := exec.Command("go", "build", 
                "-trimpath",
                "-ldflags", "-s -w -buildid=",
                "-o", "tun2socks_android",
                "./cmd/tun2socks",
            )
            
            cmd.Env = append(os.Environ(),
                "GOOS=android",
                "GOARCH=arm64",
                "CGO_ENABLED=1",
                "CC=" + os.Getenv("ANDROID_NDK_ROOT") + "/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang",
                "CXX=" + os.Getenv("ANDROID_NDK_ROOT") + "/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang++",
            )
            
            cmd.Stdout = os.Stdout
            cmd.Stderr = os.Stderr
            
            if err := cmd.Run(); err != nil {
                log.Fatalf("Failed to build: %v", err)
            }
            
            fmt.Println("Built tun2socks for Android")
        }
        EOF
        
        # Run the build
        go run build_android.go
        
        # Check if binary was created
        if [ -f "tun2socks_android" ]; then
            echo "Binary created successfully"
            file tun2socks_android
            # Test it can run (just check version)
            ./tun2socks_android --version || true
        else
            echo "Binary not created, trying alternative approach"
        fi
    
    - name: Alternative - Build using main.go
      if: failure()
      run: |
        cd tun2socks
        
        # Try building the main binary directly
        CGO_ENABLED=0 GOOS=android GOARCH=arm64 \
        go build \
          -trimpath \
          -ldflags="-s -w" \
          -o tun2socks_android_static \
          ./cmd/tun2socks
        
        if [ -f "tun2socks_android_static" ]; then
            echo "Static binary created"
            file tun2socks_android_static
        fi
    
    - name: Create minimal C wrapper (JNI)
      run: |
        # Create a simple C wrapper that execs the tun2socks binary
        mkdir -p android-wrapper
        cd android-wrapper
        
        cat > tun2socks_wrapper.c << 'EOF'
        #include <jni.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        #include <sys/types.h>
        #include <sys/wait.h>
        #include <android/log.h>
        
        #define LOG_TAG "Tun2Socks"
        #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
        #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
        
        static pid_t tun2socks_pid = 0;
        
        JNIEXPORT jint JNICALL
        Java_com_tun2socks_Tun2Socks_start(
            JNIEnv *env,
            jobject thiz,
            jint tun_fd,
            jstring socks5_addr,
            jstring dns_servers
        ) {
            const char *socks5 = (*env)->GetStringUTFChars(env, socks5_addr, 0);
            const char *dns = (*env)->GetStringUTFChars(env, dns_servers, 0);
            
            LOGI("Starting tun2socks: SOCKS5=%s, DNS=%s", socks5, dns);
            
            tun2socks_pid = fork();
            if (tun2socks_pid == 0) {
                // Child process
                char fd_str[16];
                snprintf(fd_str, sizeof(fd_str), "%d", tun_fd);
                
                char *argv[] = {
                    "tun2socks",
                    "--loglevel", "info",
                    "--interface", fd_str,
                    "--proxy", socks5,
                    "--dns", dns,
                    "--mtu", "1500",
                    NULL
                };
                
                // Execute tun2socks binary
                execvp("/data/local/tmp/tun2socks", argv);
                
                // If we get here, exec failed
                LOGE("Failed to execute tun2socks");
                exit(1);
            } else if (tun2socks_pid > 0) {
                LOGI("tun2socks started with PID: %d", tun2socks_pid);
            } else {
                LOGE("Failed to fork tun2socks process");
            }
            
            (*env)->ReleaseStringUTFChars(env, socks5_addr, socks5);
            (*env)->ReleaseStringUTFChars(env, dns_servers, dns);
            
            return tun2socks_pid > 0 ? 0 : -1;
        }
        
        JNIEXPORT void JNICALL
        Java_com_tun2socks_Tun2Socks_stop(
            JNIEnv *env,
            jobject thiz
        ) {
            if (tun2socks_pid > 0) {
                LOGI("Stopping tun2socks (PID: %d)", tun2socks_pid);
                kill(tun2socks_pid, SIGTERM);
                waitpid(tun2socks_pid, NULL, 0);
                tun2socks_pid = 0;
            }
        }
        
        JNIEXPORT jboolean JNICALL
        Java_com_tun2socks_Tun2Socks_isRunning(
            JNIEnv *env,
            jobject thiz
        ) {
            if (tun2socks_pid > 0) {
                // Check if process is still alive
                if (kill(tun2socks_pid, 0) == 0) {
                    return JNI_TRUE;
                }
                tun2socks_pid = 0;
            }
            return JNI_FALSE;
        }
        
        JNIEXPORT jstring JNICALL
        Java_com_tun2socks_Tun2Socks_getVersion(
            JNIEnv *env,
            jobject thiz
        ) {
            return (*env)->NewStringUTF(env, "xjasonlyu/tun2socks v2.5.0");
        }
        EOF
        
        # Build the wrapper as shared library
        $ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang \
          -shared -fPIC -o libtun2socks.so \
          tun2socks_wrapper.c \
          -llog
    
    - name: Create Android AAR package
      run: |
        # Create AAR structure
        mkdir -p tun2socks-aar
        cd tun2socks-aar
        
        # Create directories
        mkdir -p aar/jni/arm64-v8a
        mkdir -p aar/assets
        
        # Copy binaries
        if [ -f "../tun2socks/tun2socks_android" ]; then
            cp ../tun2socks/tun2socks_android aar/assets/tun2socks
            chmod +x aar/assets/tun2socks
        elif [ -f "../tun2socks/tun2socks_android_static" ]; then
            cp ../tun2socks/tun2socks_android_static aar/assets/tun2socks
            chmod +x aar/assets/tun2socks
        fi
        
        # Copy wrapper library
        cp ../android-wrapper/libtun2socks.so aar/jni/arm64-v8a/
        
        # Create AndroidManifest.xml
        cat > aar/AndroidManifest.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android"
            package="com.tun2socks">
            
            <uses-permission android:name="android.permission.INTERNET" />
            <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
            <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
            
            <application>
                <service
                    android:name="android.net.VpnService"
                    android:permission="android.permission.BIND_VPN_SERVICE">
                    <intent-filter>
                        <action android:name="android.net.VpnService" />
                    </intent-filter>
                </service>
            </application>
        </manifest>
        EOF
        
        # Create Java wrapper
        mkdir -p aar/com/tun2socks
        
        cat > aar/com/tun2socks/Tun2Socks.java << 'EOF'
        package com.tun2socks;
        
        import android.content.Context;
        import android.system.Os;
        import android.util.Log;
        
        import java.io.File;
        import java.io.FileOutputStream;
        import java.io.InputStream;
        import java.io.OutputStream;
        
        public class Tun2Socks {
            private static final String TAG = "Tun2Socks";
            
            static {
                System.loadLibrary("tun2socks");
            }
            
            // Native methods
            private static native int start(int tunFd, String socks5Addr, String dnsServers);
            private static native void stop();
            private static native boolean isRunning();
            private static native String getVersion();
            
            private Context context;
            private boolean initialized = false;
            
            public Tun2Socks(Context context) {
                this.context = context;
            }
            
            public boolean initialize() {
                if (initialized) return true;
                
                try {
                    // Extract tun2socks binary to app's files directory
                    File filesDir = context.getFilesDir();
                    File binaryFile = new File(filesDir, "tun2socks");
                    
                    if (!binaryFile.exists()) {
                        // Try to extract from assets
                        extractBinary(binaryFile);
                    }
                    
                    if (binaryFile.exists() && binaryFile.setExecutable(true)) {
                        Log.d(TAG, "tun2socks binary ready at: " + binaryFile.getAbsolutePath());
                        initialized = true;
                        return true;
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Failed to initialize tun2socks", e);
                }
                
                return false;
            }
            
            private void extractBinary(File targetFile) throws Exception {
                // In production, you would extract from assets
                // For now, we'll create a placeholder
                try (OutputStream os = new FileOutputStream(targetFile)) {
                    os.write("#!/system/bin/sh\necho 'tun2socks placeholder'".getBytes());
                }
                
                Log.d(TAG, "Placeholder binary created");
            }
            
            public int startTun2Socks(int tunFd, String socks5Host, int socks5Port, String dnsServers) {
                if (!initialized && !initialize()) {
                    return -1;
                }
                
                String socks5Addr = socks5Host + ":" + socks5Port;
                return start(tunFd, socks5Addr, dnsServers);
            }
            
            public void stopTun2Socks() {
                stop();
            }
            
            public boolean isTun2SocksRunning() {
                return isRunning();
            }
            
            public String getTun2SocksVersion() {
                return getVersion();
            }
            
            public static class Config {
                public String socks5Host = "127.0.0.1";
                public int socks5Port = 10808;
                public String dnsServers = "8.8.8.8,8.8.4.4";
                public boolean enableUDP = true;
                public int mtu = 1500;
            }
        }
        EOF
        
        # Create simple VpnService helper
        cat > aar/com/tun2socks/VpnHelper.java << 'EOF'
        package com.tun2socks;
        
        import android.net.VpnService;
        import android.os.ParcelFileDescriptor;
        
        public class VpnHelper {
            
            public static ParcelFileDescriptor createVpnInterface(VpnService service, 
                String localIp, String dns, int mtu) {
                
                VpnService.Builder builder = service.new Builder();
                
                // Add local address
                if (localIp != null) {
                    builder.addAddress(localIp, 24);
                } else {
                    builder.addAddress("10.0.0.2", 24);
                }
                
                // Add DNS
                if (dns != null) {
                    String[] dnsServers = dns.split(",");
                    for (String server : dnsServers) {
                        builder.addDnsServer(server.trim());
                    }
                } else {
                    builder.addDnsServer("8.8.8.8");
                    builder.addDnsServer("8.8.4.4");
                }
                
                // Add route (all traffic)
                builder.addRoute("0.0.0.0", 0);
                
                // Set MTU
                if (mtu > 0) {
                    builder.setMtu(mtu);
                }
                
                builder.setSession("Tun2Socks VPN");
                
                return builder.establish();
            }
        }
        EOF
        
        # Create proguard rules
        cat > aar/proguard-rules.pro << 'EOF'
        -keep class com.tun2socks.** { *; }
        -keepclassmembers class com.tun2socks.** {
            *;
        }
        -keepclasseswithmembernames class * {
            native <methods>;
        }
        -dontwarn com.tun2socks.**
        EOF
        
        # Package as AAR
        cd aar
        zip -r ../tun2socks.aar .
        
        echo "AAR created:"
        ls -lh ../tun2socks.aar
    
    - name: Create gradle module
      run: |
        # Create a proper Android library module
        mkdir -p android-library
        cd android-library
        
        # Create build.gradle
        cat > build.gradle << 'EOF'
        plugins {
            id 'com.android.library'
        }
        
        android {
            namespace 'com.tun2socks'
            compileSdk 34
            
            defaultConfig {
                minSdk 21
                targetSdk 34
                versionCode 1
                versionName "1.0.0"
                
                externalNativeBuild {
                    cmake {
                        cppFlags ""
                        abiFilters 'arm64-v8a'
                    }
                }
            }
            
            buildTypes {
                release {
                    minifyEnabled false
                    proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                }
            }
            
            externalNativeBuild {
                cmake {
                    path "src/main/cpp/CMakeLists.txt"
                }
            }
            
            sourceSets {
                main {
                    assets.srcDirs = ['src/main/assets']
                    jniLibs.srcDirs = ['src/main/jniLibs']
                }
            }
        }
        
        dependencies {
            implementation 'androidx.annotation:annotation:1.7.0'
        }
        EOF
        
        # Create directory structure
        mkdir -p src/main/java/com/tun2socks
        mkdir -p src/main/jniLibs/arm64-v8a
        mkdir -p src/main/assets
        mkdir -p src/main/cpp
        
        # Copy files from previous step
        cp -r ../tun2socks-aar/aar/com/tun2socks/*.java src/main/java/com/tun2socks/
        cp ../tun2socks-aar/aar/jni/arm64-v8a/libtun2socks.so src/main/jniLibs/arm64-v8a/
        
        # Copy binary to assets
        if [ -f "../tun2socks-aar/aar/assets/tun2socks" ]; then
            cp "../tun2socks-aar/aar/assets/tun2socks" src/main/assets/
        fi
        
        # Create CMakeLists.txt
        cat > src/main/cpp/CMakeLists.txt << 'EOF'
        cmake_minimum_required(VERSION 3.18.1)
        
        add_library(tun2socks SHARED IMPORTED)
        set_target_properties(tun2socks PROPERTIES
            IMPORTED_LOCATION ${CMAKE_CURRENT_SOURCE_DIR}/../../../../jniLibs/arm64-v8a/libtun2socks.so)
        
        # No need to build anything, just use pre-built library
        EOF
        
        # Create AndroidManifest.xml
        cat > src/main/AndroidManifest.xml << 'EOF'
        <?xml version="1.0" encoding="utf-8"?>
        <manifest xmlns:android="http://schemas.android.com/apk/res/android"
            package="com.tun2socks">
            
            <uses-permission android:name="android.permission.INTERNET" />
            <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
            
        </manifest>
        EOF
        
        # Create proguard rules
        cp ../tun2socks-aar/aar/proguard-rules.pro .
    
    - name: Build final AAR
      run: |
        cd android-library
        
        # Build the library
        ./gradlew assembleRelease
        
        echo "Built AAR files:"
        find . -name "*.aar" -type f -exec ls -lh {} \;
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: tun2socks-build
        path: |
          tun2socks-aar/tun2socks.aar
          android-library/build/outputs/aar/*.aar
          tun2socks/tun2socks_android*
        retention-days: 7
