name: Build tun2socks AAR (arm64, full exports)

on:
  workflow_dispatch:

jobs:
  build-aar:
    runs-on: ubuntu-latest
    env:
      JAVA_VERSION: '17'
      ANDROID_COMPILE_SDK: 34
      ANDROID_BUILD_TOOLS: 34.0.0
      ANDROID_NDK_PACKAGE: ndk;27.2.12479015
      GO_VERSION: '1.22.6'

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3
        with:
          api-level: ${{ env.ANDROID_COMPILE_SDK }}
          components: build-tools;${{ env.ANDROID_BUILD_TOOLS }}

      - name: Install NDK
        run: |
          set -euxo pipefail
          sdkmanager --sdk_root="${ANDROID_SDK_ROOT}" "${ANDROID_NDK_PACKAGE}"
          ls -1 "${ANDROID_SDK_ROOT}/ndk" || true
          NDK_DIR="$(ls -d ${ANDROID_SDK_ROOT}/ndk/* | head -n1)"
          echo "NDK_DIR=${NDK_DIR}" >> $GITHUB_ENV

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build libtun2socks.so (arm64) with exported C symbols
        run: |
          set -euxo pipefail

          # Create Go module with wrapper that exports C-callable entry points
          mkdir -p core && cd core
          go mod init example.com/tun2socks-wrapper
          go get github.com/xjasonlyu/tun2socks/v2@latest

          cat > main.go <<'EOF'
          package main

          /*
          #cgo LDFLAGS: -llog
          #include <stdlib.h>
          */
          import "C"

          import (
            "encoding/json"
            "fmt"
            "strings"
            "unsafe"

            ts "github.com/xjasonlyu/tun2socks/v2/engine"
          )

          var started bool

          // build a minimal engine JSON config from fd and proxy URL.
          func buildConfig(fd int, proxy string) string {
            // Normalize proxy: accept "socks5://127.0.0.1:10808" or "127.0.0.1:10808"
            p := proxy
            if !strings.Contains(p, "://") {
              p = "socks5://" + p
            }
            cfg := map[string]any{
              "device": map[string]any{
                "fdbased": map[string]any{
                  "fd": fd,
                },
              },
              "proxy": map[string]any{
                "socks5": map[string]any{
                  "addr": p,
                },
              },
              "netstack": map[string]any{
                "enable": true,
              },
            }
            b, _ := json.Marshal(cfg)
            return string(b)
          }

          //export tun2socks_start
          func tun2socks_start(fd C.int, proxy *C.char) C.int {
            if started {
              return 0
            }
            goProxy := C.GoString(proxy)
            cfg := buildConfig(int(fd), goProxy)
            if err := ts.Start(cfg); err != nil {
              return C.int(-1)
            }
            started = true
            return 0
          }

          //export tun2socks_stop
          func tun2socks_stop() C.int {
            if !started {
              return 0
            }
            if err := ts.Stop(); err != nil {
              return C.int(-1)
            }
            started = false
            return 0
          }

          //export tun2socks_info
          func tun2socks_info() *C.char {
            s := fmt.Sprintf("tun2socks wrapper: started=%v", started)
            return C.CString(s)
          }

          func main() {}
          EOF

          # Cross-compile for Android arm64 using NDK clang
          CC="${NDK_DIR}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android34-clang"
          export CC
          export CGO_ENABLED=1
          export GOOS=android
          export GOARCH=arm64

          # Build shared object
          go build -buildmode=c-shared -o libtun2socks.so

          # Stage into Android jniLibs
          cd ..
          mkdir -p tun2socks-android/src/main/jniLibs/arm64-v8a
          cp core/libtun2socks.so tun2socks-android/src/main/jniLibs/arm64-v8a/

      - name: Create Android library with JNI bridge and Gradle
        run: |
          set -euxo pipefail
          mkdir -p tun2socks-android/src/main/{cpp,java/com/example/tun2socks}
          
          # Java API
          cat > tun2socks-android/src/main/java/com/example/tun2socks/Tun2Socks.java <<'EOF'
          package com.example.tun2socks;

          public class Tun2Socks {
              static {
                  System.loadLibrary("tun2socks_jni");
                  System.loadLibrary("tun2socks");
              }

              public static native int start(int tunFd, String proxyUrl);
              public static native int stop();
              public static native String coreInfo();
          }
          EOF

          # JNI bridge that calls exported C symbols
          cat > tun2socks-android/src/main/cpp/tun2socks_jni.c <<'EOF'
          #include <jni.h>
          #include <android/log.h>
          #include <dlfcn.h>
          #include <errno.h>
          #include <string.h>

          #define LOG_TAG "Tun2SocksJNI"
          #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
          #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)

          typedef int (*start_fn)(int fd, const char *url);
          typedef int (*stop_fn)();
          typedef const char* (*info_fn)();

          static void *handle = NULL;
          static start_fn core_start = NULL;
          static stop_fn core_stop = NULL;
          static info_fn core_info = NULL;

          static void ensure_loaded() {
              if (handle) return;
              handle = dlopen("libtun2socks.so", RTLD_NOW);
              if (!handle) {
                  LOGE("dlopen failed: %s", dlerror());
                  return;
              }
              core_start = (start_fn)dlsym(handle, "tun2socks_start");
              core_stop  = (stop_fn)dlsym(handle, "tun2socks_stop");
              core_info  = (info_fn)dlsym(handle, "tun2socks_info");
              LOGI("Symbols: start=%p stop=%p info=%p", core_start, core_stop, core_info);
          }

          JNIEXPORT jint JNICALL
          Java_com_example_tun2socks_Tun2Socks_start(JNIEnv *env, jclass, jint fd, jstring proxyUrl) {
              ensure_loaded();
              if (!core_start) {
                  LOGE("No tun2socks_start symbol");
                  return -2;
              }
              const char *url = (*env)->GetStringUTFChars(env, proxyUrl, 0);
              errno = 0;
              int rc = core_start(fd, url);
              LOGI("tun2socks_start rc=%d errno=%d (%s)", rc, errno, strerror(errno));
              (*env)->ReleaseStringUTFChars(env, proxyUrl, url);
              return rc;
          }

          JNIEXPORT jint JNICALL
          Java_com_example_tun2socks_Tun2Socks_stop(JNIEnv *env, jclass) {
              ensure_loaded();
              if (!core_stop) {
                  LOGE("No tun2socks_stop symbol");
                  return -2;
              }
              errno = 0;
              int rc = core_stop();
              LOGI("tun2socks_stop rc=%d errno=%d (%s)", rc, errno, strerror(errno));
              return rc;
          }

          JNIEXPORT jstring JNICALL
          Java_com_example_tun2socks_Tun2Socks_coreInfo(JNIEnv *env, jclass) {
              ensure_loaded();
              if (!core_info) {
                  return (*env)->NewStringUTF(env, "info not exported");
              }
              const char *s = core_info();
              return (*env)->NewStringUTF(env, s ? s : "null");
          }
          EOF

          # Android.mk for ndk-build
          cat > tun2socks-android/src/main/cpp/Android.mk <<'EOF'
          LOCAL_PATH := $(call my-dir)

          include $(CLEAR_VARS)
          LOCAL_MODULE    := tun2socks_jni
          LOCAL_SRC_FILES := tun2socks_jni.c
          LOCAL_LDLIBS    := -llog -ldl
          include $(BUILD_SHARED_LIBRARY)
          EOF

          # Module build.gradle
          cat > tun2socks-android/build.gradle <<'EOF'
          plugins {
              id 'com.android.library'
          }
          android {
              namespace "com.example.tun2socks"
              compileSdk 34
              defaultConfig {
                  minSdk 21
                  targetSdk 34
                  ndk {
                      abiFilters 'arm64-v8a'
                  }
              }
              sourceSets {
                  main {
                      java.srcDirs = ['src/main/java']
                      jniLibs.srcDirs = ['src/main/jniLibs']
                  }
              }
              externalNativeBuild {
                  ndkBuild {
                      path "src/main/cpp/Android.mk"
                  }
              }
          }
          EOF

          # Top-level Gradle
          echo "include ':tun2socks-android'" > settings.gradle
          cat > build.gradle <<'EOF'
          buildscript {
              repositories { google(); mavenCentral() }
              dependencies { classpath 'com.android.tools.build:gradle:8.2.0' }
          }
          allprojects {
              repositories { google(); mavenCentral() }
          }
          EOF

      - name: Initialize Gradle wrapper
        run: gradle wrapper --gradle-version 8.2

      - name: Build AAR (release)
        run: ./gradlew :tun2socks-android:assembleRelease --stacktrace

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: tun2socks-aar-arm64
          path: tun2socks-android/build/outputs/aar/*.aar
